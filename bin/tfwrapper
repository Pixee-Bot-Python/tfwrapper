#!/usr/bin/env python3
"""Python wrapper for Terraform."""

import argparse
import os
import pickle
import random
import shutil
import string
import subprocess
import time
import sys
from copy import deepcopy
from datetime import datetime
from termcolor import colored

import boto3
import yaml


def load_wrapper_config(args):
    """Load wrapper config from args. Validate args and autodetect current stack."""
    # convert args to dict
    wrapper_config = deepcopy(vars(args))

    # detect confdir and rootdir locations
    parents_count = 0
    while parents_count < 5:
        if os.path.isdir('../' * parents_count + wrapper_config['confdir']):
            wrapper_config['confdir'] = '../' * parents_count + wrapper_config['confdir']
            break
        parents_count += 1

    wrapper_config['rootdir'] = os.path.dirname(os.path.abspath(wrapper_config['confdir']))

    # detect parent dirs
    if wrapper_config['rootdir'] == os.path.abspath('') and wrapper_config['account'] is None:
        wrapper_config['account'] = 'root'
    else:
        count_up = 0
        count_down = parents_count

        # check wether we are in global environment
        if (os.path.basename(os.path.abspath('.')) == '_global' or
                os.path.basename(os.path.abspath('..')) == '_global' or
                wrapper_config['environment'] == 'global'):
            parents_list = ['account', 'environment', 'stack']
        else:
            parents_list = ['account', 'environment', 'region', 'stack']

        # detect dirs
        while count_down > 0:
            if wrapper_config[parents_list[count_up]] is None:
                wrapper_config[parents_list[count_up]] = os.path.basename(os.path.abspath('./' + '../' * (count_down - 1)))
            count_down -= 1
            count_up += 1

        # support both _global (fs) and global (param)
        if wrapper_config['environment'] == '_global':
            wrapper_config['environment'] = 'global'

    # configure state bucket
    root_stack_config = load_stack_config(wrapper_config['confdir'], 'root', None, None, None)
    state_account = root_stack_config['aws']['general']['account']
    state_region = root_stack_config['aws']['general']['region']
    wrapper_config['state_region'] = state_region
    wrapper_config['state_bucket'] = "s3.terraform.root-state.{}.{}".format(state_region,
                                                                            state_account)

    return wrapper_config


def load_stack_config(confdir, account, environment, region, stack):
    """Load configuration from YAML file."""
    if account == 'root':
        with open(confdir + '/root.yml', 'r') as f:
            stack_config = yaml.load(f)
    elif environment == 'global':
        with open('{}/{}_global_{}.yml'.format(confdir, account, stack), 'r') as f:
            stack_config = yaml.load(f)
    else:
        with open('{}/{}_{}_{}_{}.yml'.format(confdir, account, environment, region, stack), 'r') as f:
            stack_config = yaml.load(f)

    return stack_config


def set_aws_env(sts_client, role_arn):
    """Configure AWS env."""
    random_id = ''.join(random.choice(string.ascii_letters) for x in range(10))
    session_name = 'terraform-{}'.format(random_id)

    response = sts_client.assume_role(
        RoleArn=role_arn,
        RoleSessionName=session_name
    )

    os.environ['AWS_ACCESS_KEY_ID'] = response['Credentials']['AccessKeyId']
    os.environ['AWS_SECRET_ACCESS_KEY'] = response['Credentials']['SecretAccessKey']
    os.environ['AWS_SECURITY_TOKEN'] = response['Credentials']['SessionToken']
    os.environ['AWS_SESSION_TOKEN'] = response['Credentials']['SessionToken']


def set_terraform_vars(vars):
    """Configure Terraform env."""
    for var, value in vars.items():
        if value is not None:
            os.environ['TF_VAR_{}'.format(var)] = value


def get_stack_path(wrapper_config, local=False):
    """Return stack path."""
    rootdir = wrapper_config['rootdir']
    account = wrapper_config['account']
    environment = wrapper_config['environment']
    region = wrapper_config['region']
    stack = wrapper_config['stack']

    if local:
        if environment == 'global':
            stack_path = '{}/{}/_global/{}'.format(rootdir, account, stack)
        else:
            stack_path = '{}/{}/{}/{}/{}'.format(rootdir, account, environment, region, stack)
    else:
        if environment == 'global':
            stack_path = '{}/_global/{}'.format(account, stack)
        else:
            stack_path = '{}/{}/{}/{}'.format(account, environment, region, stack)

    return stack_path


def get_local_state_path(wrapper_config):
    """Return local state path."""
    rootdir = wrapper_config['rootdir']
    local_state_path = '{}/{}/.terraform/terraform.tfstate'.format(rootdir,
                                                                   get_stack_path(wrapper_config, local=True))

    return local_state_path


def get_remote_state_path(wrapper_config):
    """Return local state path."""
    remote_state_path = '{}/terraform.state'.format(get_stack_path(wrapper_config))

    return remote_state_path


def check_remote_state(wrapper_config):
    """Bootstrap if there is no existing state."""
    if wrapper_config['account'] != 'root':
        if not os.path.isfile(get_local_state_path(wrapper_config)):
            bootstrap(wrapper_config)


def bootstrap(wrapper_config):
    """Bootstrap project."""
    account = wrapper_config['account']

    if not account == 'root':
        rootdir = wrapper_config['rootdir']
        environment = wrapper_config['environment']
        region = wrapper_config['region']
        stack = wrapper_config['stack']
        state_region = wrapper_config['state_region']
        state_bucket = wrapper_config['state_bucket']

        if wrapper_config.get('template') is None:
            if environment == 'global':
                template = 'global'
            else:
                template = 'basic'
        else:
            template = wrapper_config['template']

        # bootstrap Terraform files
        stack_path = get_stack_path(wrapper_config, local=True)
        if not os.path.isdir(stack_path):
            shutil.copytree('{}/templates/{}'.format(rootdir, template), stack_path)

        # bootstrap remote state
        remote_state_file = get_remote_state_path(wrapper_config)
        local_state_file = get_local_state_path(wrapper_config)
        if not os.path.isfile(local_state_file):
            subprocess.run(['terraform', 'remote', 'config', '-backend=s3',
                            '-backend-config', 'bucket={}'.format(state_bucket),
                            '-backend-config', 'key={}'.format(remote_state_file),
                            '-backend-config', 'region={}'.format(state_region),
                            '-backend-config', 'acl=bucket-owner-full-control'],
                           cwd=stack_path)
    else:
        print('Nothing to bootstrap')


def lock_stack(wrapper_config, s3_resource):
    """Lock stack."""
    if not wrapper_config['account'] == 'root':
        if not check_stack_lock(wrapper_config, s3_resource):
            print('Locking state.')
            lock_file_path = '{}/tfwrapper.lock'.format(get_stack_path(wrapper_config))
            lock_file = s3_resource.Object(wrapper_config['state_bucket'],
                                           lock_file_path)

            lock_time = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
            message = '{} {}'.format(lock_time, wrapper_config.get('message', 'Terraform wrapper action in progress.'))
            print(message)

            lock_file.put(ACL='bucket-owner-full-control', Body=message.encode('utf-8'))
            return True
        else:
            print('Cannot acquire state lock.')
            return False
    else:
        print('Root state account, no need to acquire state lock.')
        return True


def unlock_stack(wrapper_config, s3_resource):
    """Unlock stack."""
    if not wrapper_config['account'] == 'root':
        if check_stack_lock(wrapper_config, s3_resource):
            print('Unlocking state.')
            lock_file_path = '{}/tfwrapper.lock'.format(get_stack_path(wrapper_config))
            lock_file = s3_resource.Object(wrapper_config['state_bucket'],
                                           lock_file_path)

            lock_file.delete()
            return True
        else:
            print('No lock to remove.')
            return False
    else:
        print('Root state account, no need to release state lock.')
        return True


def check_stack_lock(wrapper_config, s3_resource):
    """Check stack lock."""
    if not wrapper_config['account'] == 'root':
        state_bucket = s3_resource.Bucket(wrapper_config['state_bucket'])
        lock_file_path = '{}/tfwrapper.lock'.format(get_stack_path(wrapper_config))

        objects = list(state_bucket.objects.filter(Prefix=lock_file_path))
        if len(objects) > 0 and objects[0].key == lock_file_path:
            lock_file_path = '{}/tfwrapper.lock'.format(get_stack_path(wrapper_config))
            lock_file = s3_resource.Object(wrapper_config['state_bucket'],
                                           lock_file_path)

            print('State is locked : {}'.format(lock_file.get()['Body'].read().decode('utf-8')))
            return True
        else:
            print('State is not locked.')
            return False
    else:
        print('Root state account, state cannot be locked.')
        return False


def run_terraform(action, wrapper_config):
    """Run Terraform command."""
    rootdir = wrapper_config['rootdir']

    tf_params = wrapper_config['tf_params']
    account = wrapper_config['account']
    environment = wrapper_config['environment']
    region = wrapper_config['region']
    stack = wrapper_config['stack']

    # support for custom parameters
    command = ["terraform", action]
    if tf_params is not None:
        if tf_params and tf_params[0] == '--':
                tf_params = tf_params[1:]
        command += tf_params

    if account == 'root':
        subprocess.run(command, cwd=rootdir)
    elif environment == 'global':
        subprocess.run(command,
                       cwd='{}/{}/_global/{}'.format(rootdir, account, stack))
    else:
        subprocess.run(command,
                       cwd='{}/{}/{}/{}/{}'.format(rootdir, account, environment, region, stack))


def terraform_apply(wrapper_config):
    """Terraform apply wrapper function."""
    check_remote_state(wrapper_config)

    # do not force plan if unsafe
    if wrapper_config['unsafe']:
        run_terraform('apply', wrapper_config)
    else:
        # plan config
        plan_path = '{}/.run/plan_{}'.format(wrapper_config['rootdir'],
                                             ''.join(random.choice(string.ascii_letters) for x in range(10)))
        plan_wrapper_config = deepcopy(wrapper_config)
        plan_wrapper_config['tf_params'][1:1] = ['-out', plan_path]
        run_terraform('plan', plan_wrapper_config)

        # ask for confirmation
        colored_account = colored(plan_wrapper_config['account'], 'yellow')
        colored_environement = colored(plan_wrapper_config['environment'], 'red')
        colored_region = colored(plan_wrapper_config['region'], 'blue')
        colored_stack = colored(plan_wrapper_config['stack'], 'green')

        if plan_wrapper_config['environment'] == 'global':
            env_msg = '''
    Account : {}
Environment : {}
      Stack : {}
            '''.format(colored_account, colored_environement, colored_stack)
        else:
            env_msg = '''
    Account : {}
Environment : {}
     Region : {}
      Stack : {}
            '''.format(colored_account, colored_environement, colored_region, colored_stack)

        print('\nDo you really want to apply this plan on the following stack ?')
        print(env_msg)
        apply_input = input("'yes' to confirm : ")

        if apply_input == 'yes':
            # apply config
            apply_wrapper_config = deepcopy(wrapper_config)
            apply_wrapper_config['tf_params'].append(plan_path)
            run_terraform('apply', apply_wrapper_config)
        else:
            print('\nAborting apply.')

        # delete plan
        os.remove(plan_path)


def terraform_destroy(wrapper_config):
    """Terraform destroy wrapper function."""
    run_terraform('destroy', wrapper_config)


def terraform_fmt(wrapper_config):
    """Terraform fmt wrapper function."""
    run_terraform('fmt', wrapper_config)


def terraform_get(wrapper_config):
    """Terraform get wrapper function."""
    # force update
    if not any('-update' in x for x in wrapper_config['tf_params']):
        wrapper_config['tf_params'][1:1] = ['-update']

    # call subcommand
    run_terraform('get', wrapper_config)


def terraform_graph(wrapper_config):
    """Terraform graph wrapper function."""
    run_terraform('graph', wrapper_config)


def terraform_import(wrapper_config):
    """Terraform import wrapper function."""
    run_terraform('import', wrapper_config)


def terraform_output(wrapper_config):
    """Terraform output wrapper function."""
    run_terraform('output', wrapper_config)


def terraform_plan(wrapper_config):
    """Terraform plan wrapper function."""
    check_remote_state(wrapper_config)
    run_terraform('plan', wrapper_config)


def terraform_refresh(wrapper_config):
    """Terraform refresh wrapper function."""
    run_terraform('refresh', wrapper_config)


def terraform_show(wrapper_config):
    """Terraform show wrapper function."""
    run_terraform('show', wrapper_config)


def terraform_state(wrapper_config):
    """Terraform state wrapper function."""
    run_terraform('state', wrapper_config)


def terraform_taint(wrapper_config):
    """Terraform taint wrapper function."""
    run_terraform('taint', wrapper_config)


def terraform_untaint(wrapper_config):
    """Terraform untaint wrapper function."""
    run_terraform('untaint', wrapper_config)


def terraform_validate(wrapper_config):
    """Terraform validate wrapper function."""
    run_terraform('validate', wrapper_config)


def main():
    """Main function."""
    # terraforms params doc
    tf_params_help = 'Any Terraform parameters after a "--" delimiter'

    # argparse
    parser = argparse.ArgumentParser(description='Terraform wrapper.')
    parser.add_argument('-c', '--confdir',
                        help='Configuration directory. Used to detect the project root. Defaults to conf.',
                        default='conf')
    parser.add_argument('-a', '--account',
                        help='Target account. Autodetected if none is provided.',
                        nargs='?')
    parser.add_argument('-e', '--environment',
                        help='Target environment. Autodetected if none is provided.',
                        nargs='?')
    parser.add_argument('-r', '--region',
                        help='Target region. Autodetected if none is provided.',
                        nargs='?')
    parser.add_argument('-s', '--stack', help='Target stack. Autodetected if none is provided.',
                        nargs='?')

    subparsers = parser.add_subparsers(help='subcommands')

    parser_apply = subparsers.add_parser('apply', help='terraform apply')
    parser_apply.set_defaults(func=terraform_apply)
    parser_apply.add_argument('-u', '--unsafe',
                              help='Do not force plan and human interaction before apply.',
                              action='store_true', default=False)
    parser_apply.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_destroy = subparsers.add_parser('destroy', help='terraform destroy')
    parser_destroy.set_defaults(func=terraform_destroy)
    parser_destroy.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_fmt = subparsers.add_parser('fmt', help='terraform fmt')
    parser_fmt.set_defaults(func=terraform_fmt)
    parser_fmt.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_get = subparsers.add_parser('get', help='terraform get')
    parser_get.set_defaults(func=terraform_get)
    parser_get.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_graph = subparsers.add_parser('graph', help='terraform graph')
    parser_graph.set_defaults(func=terraform_graph)
    parser_graph.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_import = subparsers.add_parser('import', help='terraform import')
    parser_import.set_defaults(func=terraform_import)
    parser_import.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_output = subparsers.add_parser('output', help='terraform output')
    parser_output.set_defaults(func=terraform_output)
    parser_output.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_plan = subparsers.add_parser('plan', help='terraform plan')
    parser_plan.set_defaults(func=terraform_plan)
    parser_plan.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_refresh = subparsers.add_parser('refresh', help='terraform refresh')
    parser_refresh.set_defaults(func=terraform_refresh)
    parser_refresh.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_show = subparsers.add_parser('show', help='terraform show')
    parser_show.set_defaults(func=terraform_show)
    parser_show.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_state = subparsers.add_parser('state', help='terraform state')
    parser_state.set_defaults(func=terraform_state)
    parser_state.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_taint = subparsers.add_parser('taint', help='terraform taint')
    parser_taint.set_defaults(func=terraform_taint)
    parser_taint.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_untaint = subparsers.add_parser('untaint', help='terraform untaint')
    parser_untaint.set_defaults(func=terraform_untaint)
    parser_untaint.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_validate = subparsers.add_parser('validate', help='terraform validate')
    parser_validate.set_defaults(func=terraform_validate)
    parser_validate.add_argument('tf_params', nargs=argparse.REMAINDER, help=tf_params_help)

    parser_bootstrap = subparsers.add_parser('bootstrap', help='bootstrap configuration and remote states')
    parser_bootstrap.set_defaults(func=bootstrap)
    parser_bootstrap.add_argument('template', nargs='?', help='template to use during bootstrap', default=None)

    parser_bootstrap = subparsers.add_parser('lock', help='lock stack')
    parser_bootstrap.set_defaults(func=lock_stack)
    parser_bootstrap.add_argument('message', nargs='?', help='custom lock message', default='Manual state lock.')

    parser_bootstrap = subparsers.add_parser('unlock', help='unlock stack')
    parser_bootstrap.set_defaults(func=unlock_stack)

    parser_bootstrap = subparsers.add_parser('check_lock', help='check if stack is locked')
    parser_bootstrap.set_defaults(func=check_stack_lock)

    args = parser.parse_args()

    # process args
    wrapper_config = load_wrapper_config(args)

    # load config
    stack_config = load_stack_config(wrapper_config['confdir'],
                                     wrapper_config['account'],
                                     wrapper_config['environment'],
                                     wrapper_config['region'],
                                     wrapper_config['stack'])

    # Open session and get clients
    session_cache_file = '{}/.run/session_cache_{}.pickle'.format(wrapper_config['rootdir'],
                                                                  wrapper_config['account'])

    if (os.path.isfile(session_cache_file) and
        time.time() - os.stat(session_cache_file).st_mtime < 3600):
        with open(session_cache_file, 'rb') as f:
            session_cache = pickle.load(f)
        session = boto3.Session(aws_access_key_id=session_cache['credentials'].access_key,
                                aws_secret_access_key=session_cache['credentials'].secret_key,
                                aws_session_token=session_cache['credentials'].token,
                                region_name=session_cache['region'])
    else:
        session = boto3.Session(profile_name=stack_config['aws']['credentials']['profile'],
                                region_name=stack_config['aws']['general']['region'])
        session_cache = {'credentials': session.get_credentials().get_frozen_credentials(),
                         'region': session.region_name}
        with os.fdopen(os.open(session_cache_file, os.O_WRONLY | os.O_CREAT, mode=0o600), 'wb') as f:
            pickle.dump(session_cache, f, pickle.HIGHEST_PROTOCOL)

    # set boto clients/resources
    sts_client = session.client('sts')
    s3_resource = session.resource('s3')

    role_arn = 'arn:aws:iam::{}:role/{}'.format(stack_config['aws']['general']['account'],
                                                stack_config['aws']['credentials']['role'])

    # set environment variables
    set_aws_env(sts_client, role_arn)

    terraform_vars = stack_config['terraform']['vars']
    terraform_vars['account'] = wrapper_config['account']
    terraform_vars['environment'] = wrapper_config['environment']
    terraform_vars['region'] = wrapper_config['region']
    terraform_vars['stack'] = wrapper_config['stack']
    set_terraform_vars(terraform_vars)

    # manage state locking and call subcommand
    if hasattr(args, 'func'):
        func_name = args.func.__name__

        # lock management subcommands
        if func_name in ['lock_stack', 'unlock_stack', 'check_stack_lock']:
            args.func(wrapper_config, s3_resource)
        # subcommands requiring lock
        elif func_name in ['terraform_plan', 'terraform_apply', 'terraform_refresh', 'terraform_bootstrap', 'terraform_taint', 'terraform_untaint']:
            if lock_stack(wrapper_config, s3_resource):
                args.func(wrapper_config)

                # Force state ACLs
                if stack_config['aws'].get('state_acls', False):
                    put_acl_args = {}

                    if stack_config['aws']['state_acls'].get('full_control'):
                        full_control_ids = ['id={}'.format(i) for i in stack_config['aws']['state_acls']['full_control']]
                        put_acl_args['GrantFullControl'] = ','.join(full_control_ids)

                    if stack_config['aws']['state_acls'].get('read'):
                        read_ids = ['id={}'.format(i) for i in stack_config['aws']['state_acls']['read']]
                        put_acl_args['GrantRead'] = ','.join(read_ids)

                    if stack_config['aws']['state_acls'].get('write'):
                        write_ids = ['id={}'.format(i) for i in stack_config['aws']['state_acls']['write']]
                        put_acl_args['GrantWrite'] = ','.join(write_ids)

                    state_acl = s3_resource.ObjectAcl(wrapper_config['state_bucket'],
                                                      get_remote_state_path(wrapper_config))
                    state_acl.put(**put_acl_args)

                unlock_stack(wrapper_config, s3_resource)
            else:
                print('{} aborted.'.format(func_name))
                sys.exit(1)
        # other subcommands
        else:
            args.func(wrapper_config)
    else:
        parser.print_help()

    sys.exit(0)


if __name__ == "__main__":
    main()
